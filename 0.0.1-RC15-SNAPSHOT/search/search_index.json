{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"kogito-4-spark - 0.0.1-RC15-SNAPSHOT","text":"Coverage<p> Statement 74.24 Branch 48.93 </p> <p>A Kogito implementation of the dmn-4-spark API.</p>"},{"location":"#supported-runtimes","title":"Supported Runtimes","text":"<p>Spark 3.5.x (Spark 4 hopefully coming soon) based runtimes on jdk 17 (OSS 2.13 builds are also provided).</p> <p>Databricks requires the use of JNAME, with its associated reduction in support, in order to run on a non-jdk 8 VM for DBRs 14.0, 14.3 and 15.4.  16.4 moves to JDK 17 by default and also supports scala 2.13.</p>"},{"location":"#how-to-use","title":"How to Use","text":"<p>Follow these instructions found on the API page to depend on the correct version.</p> <p>Then, assuming your DMN files are available on the classpath (e.g. test/resources) define your files as:</p> <pre><code>val dmnFiles = Seq(\nDMNFile(\"common.dmn\",\nthis.getClass.getClassLoader.getResourceAsStream(\"common.dmn\").readAllBytes()\n),\nDMNFile(\"decisions.dmn\",\nthis.getClass.getClassLoader.getResourceAsStream(\"decisions.dmn\").readAllBytes()\n)\n)\n</code></pre> <p>or source them from byte arrays in a dataset using the api serialization.readVersionedFilesFromDF function.</p> <p>Define the model you wish to run (the namespace and name must be present in one of the DMNFiles):</p> <pre><code>val dmnModel = DMNModelService(name, namespace, Some(\"DQService\"), \"struct&lt;evaluate: array&lt;boolean&gt;&gt;\")\n</code></pre> <p>when the DecisionService is provided, DQService the above example, only it will be executed, using None will trigger evaluateAll semantics.  The struct definition at the end defines your output structure, use JSON to serialize the DMNResult into JSON.  You can also use the serialization.readVersionedModelServicesFromDF to load models.</p> <p>Define the DMNInputfields:</p> <pre><code>val inputFields = Seq(\nDMNInputField(\"location\", \"String\", \"testData.location\"),\nDMNInputField(\"idPrefix\", \"String\", \"testData.idPrefix\"),\nDMNInputField(\"id\", \"Int\", \"testData.id\"),\nDMNInputField(\"page\", \"Long\", \"testData.page\"),\nDMNInputField(\"department\", \"String\", \"testData.department\")\n)\n</code></pre> <p>this use the fields location, idPrefix, id, page and department to set entries in the \"testData\" DMNContext map.  Input fields can also be loaded via the serialization.readVersionedProvidersFromDF function.</p> <p>Then combine the variables into the DMNExecution you wish to run with any additional configuration (currently ignored by kogito-4-spark):</p> <pre><code>val exec = DMNExecution(dmnFiles, service, inputFields, DMNConfiguration.empty /* default value */)\n</code></pre> <p>DMNExecutions too can be loaded from serialization.readVersionedExecutionsFromDF but requires you to provide all of the other input datasets (configuration can be optionally provided via serialization.readVersionedConfigurationDF).</p> <p>finally register the DMN on your dataset (which contains the input fields):</p> <pre><code>val res = ds.withColumn(\"dmn\", com.sparkutils.dmn.DMN.dmnEval(exec))\n</code></pre> <p>you may use the optional debug parameter to capture additional information from kogito's DMNResult.</p> <p>NOTE: As with all Spark Datasets evaluation is lazy, write the dataset out to evaluate only once in-line per row as they are written.</p>"},{"location":"#supported-dmncontextproviders","title":"Supported DMNContextProviders","text":"<p>The following JSON and DDL types are supported and provided to the org.kie.dmn.api.core.DMNContext</p> <ul> <li>JSON - string json representation</li> <li>String</li> <li>Integer</li> <li>Long</li> <li>Boolean</li> <li>Double</li> <li>Float</li> <li>Binary - provided as a byte[]</li> <li>Byte</li> <li>Short</li> <li>Date - provided as a LocalDate</li> <li>Timestamp - provided as a LocalDateTime</li> <li>Decimal - provided as DecimalType(DecimalType.MAX_PRECISION, DecimalType.DEFAULT_SCALE)</li> <li>struct&lt;*&gt; - with any nested types, provided as util.Map[String, Object] with field names as the keys</li> <li>array&lt;*&gt; - of any type, provided as util.List[Object]</li> <li>map - only supports util.Map[String, Object], the values may have any type <p>Non DDL Unary DMNContextProviders may be provided via a fully qualified class name and must provide a two arg constructor of DMNContextPath, Expression.</p> <p>The data map used in the compilation of Context Providers can be configured via \"useTreeMap=true\" (default is false), this isn't terribly important for processing within Kogito but will affect JSON output ordering. (Interpreted mode is always ordered).</p>"},{"location":"#supported-dmnresultproviders","title":"Supported DMNResultProviders","text":"<ul> <li>JSON - Serializes the org.kie.dmn.api.core.DMNResult.getDecisionResults</li> <li>Struct&lt;\u2026&gt; DDL - with each field representing a decision name to result mapping</li> </ul> <p>Other DMNResultProviders may be provided via a fully qualified class name.</p> <p>When Struct DDL is used each decisionName in the Kogito DMNResult will be stored against that struct, e.g. for a decision name \"evaluate\" which returns a list of booleans the DDL:</p> <pre><code>struct&lt;evaluate: array&lt;boolean&gt;&gt;\n</code></pre> <p>should be used.  Where the decisionName is not present in the results null is used, each element will therefore be set to nullable by the library.  Where a decision result is provided which is not the in the DDL it will be ignored (debug information may however be provided).</p> <p>Use JSON to handle result schema evolution until a possible solution via Variants in Spark 4 is investigated.</p>"},{"location":"#result-processing","title":"Result Processing","text":"<p>In order to identify if a null result is due to an error or not a \"_dmnEvalStatus: Byte\" field can be added to the Struct DDL, e.g.:</p> <pre><code>struct&lt;evaluate: array&lt;boolean&gt;, evaluate_dmnEvalStatus: Byte&gt;\n</code></pre> <p>will store the Kogito DMNDecisionResult.getEvaluationStatus as a Byte with the following values:</p> DecisionEvaluationStatus (Severity) _dmnEvalStatus Int stored NOT_FOUND (kogito-4-spark only1) -6 (Typically a sign of a name mismatch) NOT_EVALUATED -5 (Should not happen) EVALUATING -4 (Should not happen) SUCCEEDED 1 SKIPPED (WARN Msg.MISSING_EXPRESSION_FOR_DECISION) -3 SKIPPED (ERROR) -2 FAILED 0 <p>These status' only replicate the Kogito DecisionEvaluationStatus usage and do not represent any business logic from the underlying DMN, that must of course be encoded in the result DLL directly.</p> <p>The top level decision result map is proxied for both DDL and JSON processing, should this lead to a performance deficit you may disable it via the config option \"fullProxyDS=false\".</p>"},{"location":"#debug-mode","title":"Debug mode","text":"<p>Use debugMode when calling evaluate to force the full DMNResult structure (without results) to be written out into an additional debugMode field, in the case where no issues are present this is likely overkill and should be kept for debug information only.  The debugMode field has the following DDL type (also found in ResultProcessors.debugDDL):</p> <pre><code>debugMode: array&lt; struct&lt; decisionId: String,\ndecisionName: String,\nhasErrors: Boolean,\nmessages: array&lt; struct&lt;\nsourceId: String,\nsourceReference: String,\nexception: String,\nfeelEvent: struct&lt;\nseverity: String,\nmessage: String,\nline: Integer,\ncolumn: Integer,\nsourceException: String,\noffendingSymbol: String\n&gt;\n&gt; &gt;,\nevaluationStatus: String\n&gt; &gt;  </code></pre> <p>In this mode the output DDL more closely mimics the Kogito DMNResult, the two output types are not compatible.</p> <p>The JSON provider when in debug mode serializes the entire DMNResult structure, when not the structure mimics the output of the Struct ddl counterpart e.g.:</p> <pre><code>{\"eval\":{\"top1\":\"0a\",\"strings\":[\"a0i\",\"b0i\",\"c0i\",\"d0i\"],\"structs\":[{\"a\":\"0\",\"b\":2061584302.16,\"d\":{\"a\":true,\"b\":true},\"c\":{\"a1\":\"b1\"}}]}}\n</code></pre> <p>becomes:</p> <pre><code>[{\"decisionId\":\"_5BD6B443-5DB7-4CA4-84E2-AC86D643FB15\",\"decisionName\":\"eval\",\"result\":{\"top1\":\"0a\",\"strings\":[\"a0i\",\"b0i\",\"c0i\",\"d0i\"],\"structs\":[{\"a\":\"0\",\"b\":2061584302.16,\"d\":{\"a\":true,\"b\":true},\"c\":{\"a1\":\"b1\"}}]},\"messages\":[],\"evaluationStatus\":\"SUCCEEDED\"}]\n</code></pre> <ol> <li> <p>The NOT_FOUND status is added by the library for the case where a _dmnEvalStatus field is provided in the ddl but this decision name that does not exist in the dmn.\u00a0\u21a9</p> </li> </ol>"},{"location":"getting_started/running_on_databricks/","title":"Running kogito-4-spark on Databricks","text":"<p>The aim is to have explicit support for LTS', other interim versions may be supported as needed.</p>","tags":["basic","getting started","beginner"]},{"location":"getting_started/running_on_databricks/#running-on-databricks-runtime-164","title":"Running on Databricks Runtime 16.4","text":"<p>Databricks supports both 2.12 and 2.13 scala versions for 16.4, ensure the correct runtime is used.</p>","tags":["basic","getting started","beginner"]},{"location":"getting_started/running_on_databricks/#testing-out-kogito-4-spark-via-notebooks","title":"Testing out kogito-4-spark via Notebooks","text":"<p>You can use the appropriate runtime kogito-4-spark_testshade artefact jar (e.g. DBR 16.4) from maven to upload into your workspace / notebook env (or add via maven).  When using Databricks make sure to use the appropriate _Version.dbr builds.</p> <p>Then using:</p> <pre><code>import com.sparkutils.dmn.kogito.tests.TestSuite\nimport com.sparkutils.dmn.kogito.TestUtils\n\nTestUtils.setPath(\"path_where_test_files_should_be_generated\")\nTestSuite.runTests()\n</code></pre> <p>in your cell will run through all of the test suite used when building kogito-4-spark.</p> <p>In Databricks notebooks you can set the path up via:</p> <pre><code>val fileLoc = \"./kogito-4-spark-testdir\"''\nTestUtils.setPath(fileLoc)\n</code></pre> <p>Ideally at the end of your runs you'll see - after 10 minutes or so and some stdout - for example a run on DBR 16.4 provides:</p> <pre><code>Time: 63.686\n\nOK (34 tests)\n\nFinished. Result: Failures: 0. Ignored: 0. Tests run: 34. Time: 633686ms.\nimport com.sparkutils.dmn.kogito.tests.TestSuite\nimport com.sparkutils.dmn.kogito.TestUtils\nfileLoc: String = ./kogito-4-spark-testdir\n</code></pre>","tags":["basic","getting started","beginner"]}]}